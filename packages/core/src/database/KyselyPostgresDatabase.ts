import { inject, injectable } from 'inversify';
import { sql, Kysely, type Selectable, PostgresDialect, type ExpressionBuilder, Transaction } from 'kysely';
import { jsonArrayFrom, jsonObjectFrom } from 'kysely/helpers/postgres';
import type { Logger } from 'pino';
import { INJECTION_TOKENS } from '../container.js';
import type { DB, Incident, LogWebhook, LogWebhookKind, ModCase, ModCaseLogMessage } from '../db.js';
import { Env } from '../util/Env.js';
import {
	IDatabase,
	type CaseWithLogMessage,
	type CreateModCaseOptions,
	type ExperimentWithOverrides,
	type GetRecentCasesAgainstOptions,
	type UpdateModCaseOptions,
} from './IDatabase.js';

// no proper ESM support
const {
	default: { Pool },
} = await import('pg');

/**
 * Our current database implementation, using kysely with types generated by prisma-kysely
 */
@injectable()
export class KyselyPostgresDatabase extends IDatabase {
	readonly #database: Kysely<DB>;

	public constructor(
		private readonly env: Env,
		@inject(INJECTION_TOKENS.logger) private readonly logger: Logger,
	) {
		super();

		this.#database = new Kysely<DB>({
			dialect: new PostgresDialect({
				pool: new Pool({
					host: this.env.postgresHost,
					port: this.env.postgresPort,
					user: this.env.postgresUser,
					password: this.env.postgresPassword,
					database: this.env.postgresDatabase,
				}),
			}),
			log: (event) => {
				if (event.level === 'error') {
					this.logger.info({ query: event.query.sql }, 'Query responsible for error');
				}
			},
		});
	}

	public override async getExperiments(): Promise<ExperimentWithOverrides[]> {
		return this.#database
			.selectFrom('Experiment')
			.selectAll()
			.select((query) => [
				jsonArrayFrom(
					query
						.selectFrom('ExperimentOverride')
						.selectAll()
						.whereRef('Experiment.name', '=', 'ExperimentOverride.experimentName'),
				).as('overrides'),
			])
			.execute();
	}

	public override async createIncident(error: Error, guildId?: string): Promise<Selectable<Incident>> {
		const causeStack = error.cause && error.cause instanceof Error ? (error.cause.stack ?? error.cause.message) : null;

		return this.#database
			.insertInto('Incident')
			.values({
				guildId,
				stack: error.stack ?? error.message,
				causeStack,
			})
			.returningAll()
			.executeTakeFirstOrThrow();
	}

	public override async getModCase(caseId: number): Promise<Selectable<CaseWithLogMessage> | undefined> {
		return this.#database
			.selectFrom('ModCase')
			.selectAll()
			.where('id', '=', caseId)
			.select(this.withLogMessage)
			.executeTakeFirst();
	}

	public override async getModCaseReferences(caseId: number): Promise<CaseWithLogMessage[]> {
		return this.#database.transaction().execute(async (trx) => {
			const references = await trx
				.selectFrom('CaseReference')
				.selectAll()
				.where('referencedById', '=', caseId)
				.execute();

			return this.getModCaseBulk(
				references.map((ref) => ref.referencesId),
				trx,
			);
		});
	}

	public override async getModCaseBulk(caseIds: number[], trx?: Transaction<DB>): Promise<CaseWithLogMessage[]> {
		if (!caseIds.length) {
			return [];
		}

		return (trx ?? this.#database)
			.selectFrom('ModCase')
			.selectAll()
			.where('id', 'in', caseIds)
			.select(this.withLogMessage)
			.execute();
	}

	public override async getRecentCasesAgainst({
		guildId,
		targetId: userId,
	}: GetRecentCasesAgainstOptions): Promise<CaseWithLogMessage[]> {
		return this.#database
			.selectFrom('ModCase')
			.selectAll()
			.where('guildId', '=', guildId)
			.where('targetId', '=', userId)
			.where('createdAt', '>', sql<Date>`NOW() - INTERVAL '1 HOUR'`)
			.orderBy('ModCase.createdAt desc')
			.select(this.withLogMessage)
			.execute();
	}

	public override async createModCase({ references, ...data }: CreateModCaseOptions): Promise<Selectable<ModCase>> {
		return this.#database.transaction().execute(async (trx) => {
			const modCase = await trx.insertInto('ModCase').values(data).returningAll().executeTakeFirstOrThrow();

			if (references.length) {
				await trx
					.insertInto('CaseReference')
					.values(references.map((referencesId) => ({ referencedById: modCase.id, referencesId })))
					.execute();
			}

			return modCase;
		});
	}

	public override async updateModCase(
		caseId: number,
		{ references, ...data }: UpdateModCaseOptions,
	): Promise<CaseWithLogMessage> {
		return this.#database.transaction().execute(async (trx) => {
			let cs: Selectable<ModCase>;

			if (Object.values(data).some((value) => value !== undefined)) {
				cs = await trx
					.updateTable('ModCase')
					.set(data)
					.where('id', '=', caseId)
					.returningAll()
					.executeTakeFirstOrThrow();
			} else {
				cs = await trx.selectFrom('ModCase').selectAll().where('id', '=', caseId).executeTakeFirstOrThrow();
			}

			if (references) {
				await trx.deleteFrom('CaseReference').where('referencedById', '=', caseId).execute();

				await trx
					.insertInto('CaseReference')
					.values(references.map((referencesId) => ({ referencedById: caseId, referencesId })))
					.execute();
			}

			const logMessage =
				(await trx.selectFrom('ModCaseLogMessage').selectAll().where('caseId', '=', caseId).executeTakeFirst()) ?? null;

			return { ...cs, logMessage };
		});
	}

	public override async deleteModCase(caseId: number): Promise<void> {
		await this.#database.deleteFrom('ModCase').where('id', '=', caseId).execute();
	}

	public override async upsertModCaseLogMessage(
		options: Selectable<ModCaseLogMessage>,
	): Promise<Selectable<ModCaseLogMessage>> {
		return this.#database
			.insertInto('ModCaseLogMessage')
			.values(options)
			.onConflict((eb) =>
				eb.constraint('ModCaseLogMessage_pkey').doUpdateSet({
					channelId: options.channelId,
					messageId: options.messageId,
				}),
			)
			.returningAll()
			.executeTakeFirstOrThrow();
	}

	public override async getLogWebhook(
		guildId: string,
		kind: LogWebhookKind,
	): Promise<Selectable<LogWebhook> | undefined> {
		return this.#database
			.selectFrom('LogWebhook')
			.selectAll()
			.where('guildId', '=', guildId)
			.where('kind', '=', kind)
			.executeTakeFirst();
	}

	private readonly withLogMessage = (query: ExpressionBuilder<DB, 'ModCase'>) => [
		jsonObjectFrom(
			query
				.selectFrom('ModCaseLogMessage')
				.selectAll('ModCaseLogMessage')
				.whereRef('ModCase.id', '=', 'ModCaseLogMessage.caseId'),
		).as('logMessage'),
	];
}
